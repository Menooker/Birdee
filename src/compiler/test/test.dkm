//require Remote

const batch_size=512
const myK_len=32
const matK=32
const features=16384
const myfeature_len=16384
const alpha=0.1
const beta=0.1

dim P as double[]=new double[batch_size*matK]
dim Q as double[]=new double[features*matK]
dim mydata_set as double[]=new double[batch_size*features]
dim gradient as double[]=new double[features*matK]



	dim sum as double[]=new double[100]
sub main()
unsafe
	dim i as int
	dim j as int
	dim k as int
	dim myp as double[]=P
	dim myq as double[]=Q
	dim dot as double=0
	for i=0;i<16384;i++
		dot+=myp[i]*myq[i]
	end
	println(dot)
	BreakPoint()
end

		/*for j=0;j<features;j++
			dot=0
			for k=0;k<matK;k++
				mydata_set[i*batch_size+features]+=P[i*matK+k]*Q[j*matK+k]
			end
		end*/
sub main2()
unsafe
	dim i as int
	dim j as int
	dim k as int
	dim base as int
	dim dot as double
	dim tmp as double
	dim qindex as int
	dim pindex as int
	dim myp as double[]=P
	dim myq as double[]=Q
	gradient[0]=0
	base=0
	dim gsum as double
	for i=0;i<batch_size;i++
		dot=0
		gsum=0
		pindex=i*matK
		for j=0;j<features;j++
			//Q[k][j]
			qindex=j*myK_len
			for k=0;k<matK;k++
				dot+=myp[pindex+k]*myq[qindex+k]
			end
			dot=mydata_set[base+j] - dot
			//println(dot)
			for k=0;k<matK;k++
				//println((pindex+k))
				myp[pindex+k]= alpha * (2 * dot * myq[qindex+k] - beta * myp[pindex+k])
				gradient[qindex+k]+= alpha * (2 * dot * myp[pindex+k] - beta * myq[qindex+k])
			end
		end
		gradient[i]=dot
		base+=myfeature_len
	end
end

/*for #i=0;#i<1000;#i++
	P[#i]=1
	Q[#i]=1
end*/
dim t as int=GetClock()
main2()
println(GetClock()-t)
gets()

