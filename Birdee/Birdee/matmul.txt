
dim round as int = 1
dim cur_round as int
dim time_total as int
dim time_calc as int
dim hosts as string[]={"10.0.3.16","10.0.3.20","10.0.3.21","10.0.3.22"}
dim ports as int[]={13070,13070,13070,13070}
dim mem_hosts as string[]={"10.0.3.16","10.0.3.20","10.0.3.21","10.0.3.22"}
dim mem_ports as int[]={11211,11211,11211,11211}
dim nodes as RemoteNode[]=ConnectNode(5080,hosts,ports,mem_hosts,mem_ports)

println("working")
dim threads as shared int=2
dim node_num as shared int=hosts.size()
dim thread_num as shared int=threads*node_num
dim n as shared int=200

//dim barrier_main as shared RemoteBarrier=new RemoteBarrier(thread_num+1)
dim counter as shared AtomicCounter=new AtomicCounter(0)
dim n2 as int=n*n
dim m1 as shared double[] global=new double[n2] global
dim m2 as shared double[] global=new double[n2] global
dim result as shared double[] global=new double[n2] global


dim mlocal as double[]=new double[n2]
dim mlocal2 as double[]=new double[n2]
function putproc(id as var) as int
	dim i as int
	for i=0;i<n2;i++
	unsafe
		mlocal2[i]=n2-i
	end
	println("to put2")
	m2[0:n2]=mlocal2[0:n2]
	println("put ok2")
end


for cur_round=0;cur_round<round;cur_round++
	dim time as int=GetClock()
	dim ii as int
	dim jj as int


	dim threadid as int=CreateThread(putproc,true,1)

	for ii=0;ii<n2;ii++
	unsafe
		mlocal[ii]=ii
	end
	println("to put1")
	m1[0:n2]=mlocal[0:n2]
	println("put ok1")
	JoinThread(threadid)

	dim time2 as int=GetClock()
	//println("time2 "+time2)
	dim ttid as int=0
	for ii=0;ii<node_num;ii++
		for jj=0;jj<threads;jj++
			nodes[ii].CreateThread(threadproc,ttid)
			ttid++
		end
	end

	for ;counter.Get()<thread_num;
		Sleep(8)
	end
	dim t as int
	t=GetClock()-time
	println("time1 "+ t)
	time_total+=t
	t=GetClock()-time2
	println("time2 "+ t)
	time_calc+=t
	counter.Set(0)
end
//print_matrix(m1)
//print_matrix(m2)
//print_matrix(result)
println("total time: "+time_total)
println("calc time: "+time_calc)
gets()

sub print_matrix(arr as double[] global)
	dim i as int
	dim j as int
	for i=0;i<n;i++
		for j=0;j<n;j++
			print(arr[i*n+j])
			print(" ")
		end
		print("\n")
	end
end

dim mym1 as double[]
dim mym2 as double[]
dim volatile sync2 as int
function threadproc(id as var) as int
unsafe
	dim tid as int=id
	dim i as int
	dim j as int
	dim k as int
	dim myn as int = n
	dim myn2 as int =n*n
	dim st as int=id % threads
	dim ths as int=threads

	//mym1[myn2*st/threads:myn2*(st+1)/threads]=m1[myn2*st/threads:myn2*(st+1)/threads]
	mym2[myn2*st/threads:myn2*(st+1)/threads]=m2[myn2*st/threads:myn2*(st+1)/threads]
	sync2@+=1
	for ;;
		if sync2==ths then
			break
		end
	end
	dim mythreads as int=thread_num
	dim sum as double
	dim line as double[]=new double[myn]
	dim col as double[]=new double[myn]
	for i=tid;i<myn;i+=mythreads
		//println(i)
		col[0:myn]=m1[i*myn : i*myn+myn]
		for j=0;j<myn;j++
			sum=0
			for k=0;k<myn;k++
				sum+=col[k] * mym2[myn*j + k]
			end
			line[j]=sum
		end
		result[i*myn : i*myn+myn]=line[0:myn]
	end
	sync2=0
	counter.Inc(1)
end

sub RemoteInitialize()

	mym1=new double[256*256]
	mym2=new double[256*256]
	println("init ok,size "+ 256*256)
end
